% AOSD report template
% Jakub Perdek 2020

%\documentclass[11pt,english,a4paper,twoside]{article}
\documentclass[11pt,slovak,a4paper,twoside]{article}



\usepackage[slovak]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{url}
\usepackage[nottoc]{tocbibind}
\usepackage{ifthen}
\usepackage{float}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{listings}


\newcommand{\magnf}{.65}
\newcommand{\codesize}{\footnotesize}
\newcommand{\lsti}{\ajset\lstinline[basicstyle=\fontsize{10}{12}\selectfont]}
\newcommand{\emp}[1]{\emph{#1}}
\newcommand{\ffe}[1]{\textsf{#1}}

% balík listings niekedy niektoré kľúčové slová nezvýrazňuje ak to nedostane príkazom tesne pred textom
\newcommand{\ajset}{\lstset{emph={class,aspect,new,call,execution,set,int,advice,public,thisJoinPointStaticPart,thisEnclosingJoinPointStaticPart,@annotation,dominates},emphstyle=\bfseries}}

\newcommand{\reporttitle}{Lightweight method for software product line feature management} % Aspect oriented configuration of software product line features and lightweight method for their automatic, Aspect oriented configuration and derivation of software product line features

\pagestyle{myheadings}
\markboth{\reporttitle}{Code quality, configurability and product derivation 2021/22, FIIT STU}

\title{\reporttitle}

\author{Jakub Perdek} % your name

\date{In\v{s}titute of informatics, information systems and software engineering\\
      Faculty of informatics and information technologies\\
      Slovak technic university in Bratislava\\[6pt]
      12. December, 2021} % modify the date if different



\begin{document}

\maketitle

\begin{abstract}

Generating product variants helps with creation of products from given domain effectively and cheaper. Not only one product is derived, but also easy adaptable products from different environments, languages and according other requirements.
 
Product derivation can be tailored to requested variability with use of aspect orientated approach, especially AspectJ language \cite{young_using_1999}, which opportunities we want to observe during fulfilling this task. We chose use of AspectJ language because it enables separate concerns such as logging, caching, pooling, but mainly is possible to exclude given aspects from execution, specific features of application based on them. Its also possible to exclude dependency on this language too.												

We are interested in applying this language by enabling configuration of certain features in code, and generating specific software product variant with possible request of implementation independence on this used language. We evaluated benefits and qualities of aspect oriented approach applied on given implementation. Then we compared them with identified problems and benefits mentioned in varying range of reimplementations of existing software  systems such as scientific calculator or database system. Provided analysis suggest importance of domain choice during software product creation. Last but not least because of such importance we evaluated influence of given domain on its implementation.

We redesigned existing Battleship game to enable managing features based on existing feature model. Many of depicted features were not implemented. The main goal is analyze possibilities of software product derivation and extent of its dependencies introduced by using AspectJ language.

Next application for analysis is derivation wide range of fractals from original algorithm realized by intervention of aspects into its execution.	We assume that task of designing features for given application is determined by value of fractal appearance. For software product line creation we can request different demands for feature model such as generating all possible derivations for next aesthetic evaluation and identification of the best candidates. Because of it we evaluated potential importance of aspect oriented application for derivation of specific fractals.
\end{abstract}


\section{Introduction} \label{introduction}

Creation of software products needs to create project and develop given solution according requirements. This is often expensive and needs analysis for every such project. One possible way is to implement software product line to make possible derive such resulting products or components and evolve then on basis of domain knowledge. Some features can be too expensive for customer to pay for them and because of it they are omitted. Others collide with necessary ones and needs to be omitted too. 

Appropriate domain analysis is required to design mandatory and voluntary features of the given system to know which products should be possible to generate and if it brings value to customer and his changing requirements. For this purpose we used feature models. In reality many of these models can exist, but only few them can support these changing needs \cite{beuche_software_2006}. We think that few relations in feature model can be expressed and solved by aspect and classes almost similarly for each group of them. But sometimes features can collide and some features can't be used together. Because of mentioned problem, its necessary to think about derivation of given product and developing certain feature without colliding ones.  

In our work we try to focus on applying aspect oriented language to develop program on feature model basis to serve as software product line. During our work we analyze applied ways how to do it in AspectJ language and its consequences on code quality, encapsulation, modularity benefits and dependencies which arise with using AspectJ language. Its an extension of object orientated language Java and is using join-point model \cite{hotdraw_deursen_2009}. We used hints and advices from papers which provided refactoring on many systems using aspect orientated languages, especially previously mentioned AspectJ.

Provided software product line and our development techniques can be later applied on fractal construction. New shapes and patterns applied at given positions during recursion drawing of given fractal are voluntary features of given model. To perceive potential aesthetic feeling from some of them is necessary to derive such products. Having appropriate product line enabling generate full range of products for their next validation is the main requirement for this specific task.


\section{Software product line and domain analysis} \label{domainAnalysis}

Variability is the main part of software product development and products are build by resolving it in a way that can build customer specific products \cite{botterweck_automating_2009}. Software products often emerge from success of market with different needs that can be provided by actual knowledge about features, then from relationships among features and relationships with software artifacts implementing these features. This known actual knowledge sources are used for systematic reuse introduces by software product line engineering \cite{reinhartz-berger_domain_2013}. Evolving products then depends on its real word applications which should provide flexible way how to apply changing needs. It can occur that given feature affects several places in models and code which can cause problems during its adaptations with other already included features. Interaction of features can cause a need to generate tailored software artifacts or software artifacts for their next modification for final application. Easier is to modify process applying change to procedure that generates these components \cite{vranic_features_2016}. 


\section{Overview of sections} \label{content}

Actual state and design of Battleship game is described in section~\ref{actualGameState}. Applied techniques for solution refactoring are presented in section~\ref{gameRefactoring}. In section~\ref{gameDerivation} we present a game derivation based on actual configuration settings and introducing annotations and expression which helps to choose content to copy into result project. 
Section~\ref{allDerivations} describes how is possible to create all possible derivations based on feature model of given solution. We are using Battleship game again with appropriate feature model for this purpose. 

We mentioned possible applications for deriving fractals in section~\ref{fractalProductLine}. Making the best design of software product line which enables derivation in all possible cases to enrich our perception and produce patterns for next validation is main goal here.  

In section~\ref{resultingModularity} we conclude impacts on modularity. We also analyze these impacts using aspect oriented programming and a given case of software product line approach.

Work which is done in given area is described in section~\ref{recentWork}. We describe some existing approaches solving similar problems that we have.

Our conclusions and next work we mentioned in section~\ref{conclusions}.

      
			
\section{Actual state and design of solution in domain application} \label{actualGameState}

To provide the most appropriate feature model which can capture potential needs of customer and domain knowledge to serve as basis for our later analysis we choose already provided one. Mentioned feature model is a part of the Battleship game in repository~\footnote{\url{https://github.com/juletx/BattleshipFeatureIDE}} for which depicts its features. Battleship game is simple game consisting of two players trying to destroy ships to each other. Lot of improvements are possible to include as additional features to make the game more interesting. We think that given feature model is based on performed domain analysis and identified many features with decision of their optionality.

Firstly, we need to mention some problems of provided implementation of Java Battleship game. Only some of mandatory features were provided in unconfigurable way. From feature model we can name features like player names, collecting statistics, computer strategy subtree and challenge as unimplemented. Many features are hardcoded and cannot easily be enhanced without code refactoring. Other aspect of such implementation is that user can't choose one option from given options without modifying code. For example choosing difficulty option in the game. The same code is repeated in many classes and methods. It lacks of some object oriented programming practices. No encapsulation resulting in free access to public variables from any class. Another identified problem was that concerns were not fully separated. For example setup of player was not included in player class. Some static method for its association to given instance should be converted to dynamic ones. This game use only console and not have any graphic user interface. We let console interface as is. Implementation not provides any possibility of product derivation at all. Potential refactoring was required then. 

Mentioned Battleship game is not large and not have many features, but can serve as potential board game domain application. We can evaluate its benefits on using aspects and creation of software product line with final product derivation. Separation of concerns is the main benefit observed from development enabling to divide components as separated classes and aspects during product derivation into separated files for each feature and making development easier. Because of aspects, new features often do not need to change existing code and require only to specify new functionality with pointcuts and managing collisions. This functionality can be easily managed using configuration file with static variables which are used in if condition of given advice. If condition is true, then functionality will be applied otherwise not. Not only extending existing or adding new features are possible using aspects. But configuring existing classes changing their parameters is possible too. These aspects can be also replaced by other aspects which use different strategy. Solution should be more configurable, modular and easily can respond to changes. Not all changes are possible, but with modularity enabling easy product derivation these can be developed separately.


\begin{figure}[t]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=\linewidth]{fig/battleshipFeatureModel.png}
									\caption{Feature diagram for Java Battleship game}
									\label{battleshipFeatureModel}
					\end{center}
\end{figure}


\section{Refactoring of domain application to be based on feature tree with using AspectJ language} \label{gameRefactoring}

We mentioned necessary changes for our domain application, Battleship game. We applied object oriented principles to make solution modular as possible, extensible, configurable and encapsulated. After changing visibility of variables, adding configuration file for base state of application and moving appropriate content to newly created classes we need to design configurable features. Resulting class diagram for project refactoring is shown in figure \ref{refactoredSchema}. During design of such configuration we tried to apply the same approaches which are described in papares focused on refactoring of existing solutions based on aspects, mainly on AspectJ language. Examples are database system \cite{kastner_case_2007} and scientific calculator \cite{botterweck_automating_2009}. We also focused on reaching maximum modularity using ApsectJ languages based on approaches from examples presented in book AspectJ in action \cite{laddad_aspectj_2003}.


\begin{figure}[t]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=\linewidth]{fig/refactoredSchema.png}
									\caption{Class Diagram of modified solution}
									\label{refactoredSchema}
					\end{center}
\end{figure}

Original game contains only main functionality consisting of mandatory features with not configurable game with computer. We added other mandatory features in object oriented way using classes and interfaces. Providing information about authors is example of introduced mandatory feature as one method in main class. For optional features we observed that is better implement them using an aspect oriented way resulting in code scattering prevention and modularity of created software product line. 

We based optional features mainly on AspectJ because of extensible functionality. For example feature for setting player names requires add another method before creating players functionality with added player names. If we not used aspects we have to use conditions and it will result in code scattering \cite{laddad_aspectj_2003}. There is also not possibility add player name variable to Player class only for this case. Aspects provides modular solution and enables to add new variables and method. It is also possible to configure or exclude them according configuration which can be loaded when application starts or changing values on runtime. Using aspects we only need to specify pointcut which provides mapping of certain location where players are created  to executed method. In this aspect method we asked for their names all in one aspect class. 

Collecting statistics is another optional domain product feature. We used aspects and classes to implement it. Aspects with pointcuts are used to specify where information should be collected and methods to collect this information. In ordinary classes we implement counter based on hashmap with strings as keys and objects implementing VariableObject interface as values. We created implementation for Integer values as counter for player hits and moves. Then we provided methods and pointcuts to count such variables during playing the game. 

We found that aspects well suit on configuration of settings in application. Different implementations of one type of aspect can be used to apply specific configuration which can easily support customer needs. In our product line we only replace parameters of overweighted methods with values from the configuration before calling these methods. We call these overweighted methods with more parameters to apply as much variables for configuration as is possible, but in other application it can depend on specific customer needs. 

Optional configuration with computer as player which replaces normal player requires to apply aspects to efficiently separate concerns of computer player from rest of the application in case to not provide such functionality and to easily segregate such part later. We applied Cuckoo's egg pattern in this case by replacing Player class with Abstract player one. Classes for player and computer player inherited from this abstract class shared functionality which is depicted in figure \ref{playerAbstraction}. Using abstract class we can use instances of these classes to represent player and its functionality. If variable computerPlayer is set to true then certain aspect is called to prevent creation of original player instance from Player class by blocking calling constructor of this class. This aspect creates instance of ComputerPlayer class and returns it as result in around method. It serves as substitution to original Player class. Its necessary to mention that applying this functionality requires to add aspect to manage priority because of collisions with difficulty features. Managing difficulty must be applied first because of setting values for next creation of player instance. After it happens then from these given arguments one of possible player instance can be created according configuration or customer needs.   

\begin{figure}[H]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[height=10cm]{fig/playerAbstraction.png}
									\caption{Player abstraction}
									\label{playerAbstraction}
					\end{center}
\end{figure}

Evaluation quality of code should show how powerful aspect oriented programming through AspectJ language is. We were inspired by approaches from refactoring papers which applied AspectJ in real world application and also AspectJ publications. We observed the same benefits, but also problems and complications with using AspectJ as were mentioned by these publications. The main problem of AspectJ is requirement to have certain naming conventions of methods and classes \cite{laddad_aspectj_2003}, dividing application into appropriate parts for changing their behaviour and hook methods to serve only to hang up aspect on them \cite{kastner_case_2007}. All these things point to explicit use of AspectJ language for refactoring of an application. Other issues can arise with certain types  of applications. For example in database system using its necessary to use priviledged aspects to access non public variables, but it means also violate encapsulation rules from given class \cite{kastner_case_2007}. Aspect behaviour can modify and use of these variables. Aspects improves modularity but it often requires mentioned supervision on design of final solution according with aspect otherwise solution will be less maintainable. The consequences of such a result mean susceptibility to error and complexity \cite{EAOR_yokomori_2011}. 
 
  \ref{problemsOfAspectJ}.

\begin{figure}[H]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=\linewidth]{fig/problemsOfAspectJEN.png}
									\caption{Problems of using AspectJ language}
									\label{problemsOfAspectJ}
					\end{center}
\end{figure}



\section{Derivation of given software product} \label{gameDerivation}

If classes and aspects are available there should be question how to separate given features from others except only to configure aspects. We come with idea, that we can copy files or part of them which represents required features. It will be based on feature models as previous part. Mandatory features from the top of the three always should be copied. Other features deeper in feature tree often require from their parents to be included. This creates new problem how to copy such files. We needed rules which can be mappped to features. We again come with idea of creating annotations with expression enabling specify condition when such feature should be copied and when not. Mapping of some features with given values to feature tree can be seen on picture \ref{derivationRules}. For example if variable playerNames is true, then all necessary \(annotated\) classes for this feature will be copied in final solution. If rule will be empty then will be evaluated as true. If any file will be without annotation or all rules have its annotations evaluated as false, then file will not be copied into final solution.

\begin{figure}[H]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=\linewidth]{fig/derivationRules.png}
									\caption{Derivation rules}
									\label{derivationRules}
					\end{center}
\end{figure}


We specified three types of annotations:

\begin{enumerate}
	\item The first annotation is //@\{\}. This annotation can be used to annotate classes, interfaces or aspects to copy whole file. Additional check can be added to program, that one of these descriptive keywords should be included after annotation.

	\item The second annotation is //\#\{\}. This annotation is suitable to include or exclude given methods. If file should be copied then at least one condition of annotation should be true. It should not be mixed with first one. 

	\item The third annotation is //\%\{\}. Using this annotation some imports \(line of code\) can be included or excluded according including or excluding given method from file. It can be used with second type of annotation. 
\end{enumerate}


We mainly use the first type of annotation, but in some cases remaining two should be used. Because that solution is modular it is possible to copy all files for each feature and make derived product functional. We can say so in situation where splitting some files with many features occurring at one place can be solution, but destroying such entities and their responsibilities at all. Because of it remaining two annotations are used. Content can be managed effectively then. Because we include or exclude methods and they can import classes which in some cases will not be part of final solution its necessary to annotate them using third annotation to be included or excluded. Typical example is functionality for setting names. Two methods are annotated with second annotation. Both of them expects that variable setNames will be true if they should be included. Only second method for setting computer name has another condition in annotation that computerOpponent variable should be set to true, otherwise method will not be copied. 
 
For making more complex condition we enable to use AND and OR operators to specify relation between variables as is described in picture \ref{complexDerivationRule}. We use recursion to evaluate them. If no operators are used, expression is evaluated as AND statement. For AND operator all children should be true. For OR operator at least one should be true.

\begin{figure}[t]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=0.65\linewidth]{fig/expresion.png}
									\caption{Complex derivation rule}
									\label{complexDerivationRule}
					\end{center}
\end{figure}


Class diagram for given solution is shown in picture \ref{derivationProductClassDiagram}. DerivationManager class manages software product derivation and contain all necessary tools for this operations. For example project copier to copy empty project without classes or FileCopy class to manage reading and writing of given file as stream. During copying it is necessary to find if file should be coped or not. For this purpose program needs to find annotation and evaluate its expression. Searching is done by DerivationAnnotationManager which is using abstract class DerivationAnnotation with all of possible derivation annotation classes which extends this mentioned abstract class and deals with its own type of processing annotation. Available are methods working with StringBuilder to save string for later use or Writer to write values immediately. Each annotation should check if some keywords are included. For example aspect, interface or class for the first type of annotation. DerivationVariableProcessor class helps DerivationAnnotationManager to evaluate expression associated with annotation. Provided implementation should evaluate expressions with AND and OR operators too. It needs to know used variables and their values to decide mentioned expression correctly. Mapping is provided by ConfigurationVariableManager.

\begin{figure}[H]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=\linewidth]{fig/DerivationClassTight.png}
									\caption{Class diagram for product derivation}
									\label{derivationProductClassDiagram}
					\end{center}
\end{figure}


We also model dynamic behavior for this generator as is shown in figure \ref{derivationProductSequenceDiagram}. At the beginning developer chooses features by setting values to configuration file. After the method for derivation is called and configuration file is applied then DerivationManager class firstly copy empty project to specified result place. FileCopy class is used then. For each file in source src directory tries to find annotation using DerivationAnnotationManager. If annotation is found then DerivationVariableProcessor class evaluates condition. If condition is true, annotation is processed using given implementation for given type of annotation. If file does not have annotations or all expressions result in false result then the file will be deleted.

\begin{figure}[!t]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=\linewidth]{fig/derivationProcessTight.png}
									\caption{Sequence diagram for product derivation}
									\label{derivationProductSequenceDiagram}
					\end{center}
\end{figure}


\section{Derivation of all types of Battleship games} \label{allDerivations}

Feature models help to determine variability in solution. According them it is possible to apply given derivation. We used variables from configuration too, but also other classes that generate all possible derivations. Changing configuration variables was necessary. We need to create another configuration file where variable names are specified with other information about them. For example variable type and number of possible cases. Variable can have boolean type and all possible cases are two, true and false. if variable have string type, cases should be named explicitly in array. For example if we can include different difficulty settings in each derived product then possible cases will be three. Namely easy, medium and hard. We named configuration file as variableRestrictions.json. Generator will generate all configuration for all cases of given variables. Described derivation method will be called for each configuration. In our project we created 2 * 2 * 2 * 2 * 3 = 48 derivations as depicts picture \ref{derivationBattleshipTypes}.  

\begin{figure}[!t]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=\linewidth]{fig/allCases.png}
									\caption{Derivation of all Battleship game types}
									\label{derivationBattleshipTypes}
					\end{center}
\end{figure}


\section{Software product line for fractals} \label{fractalProductLine}

Generating fractals should be interesting application in software product line design. Not only mathematical approach, but also user requirements should be applied during development. Feature models will then vary according these requirements. To evaluate resulting shapes and use their variable basis is necessary to derive such software enabling to draw fractals. All possible derivations should be created for their aesthetic evaluation to see which of them provides higher value to our perception. After this phase its possible to continue with development using certain derivations and enhance their structure.

During fractals analysis we constructed many types of fractals. Some of them are created dividing certain shapes to some extent like Sierpinskeho fractal \cite{pelanek_programatorska_2012}, others extends to space using given iteration parameter. The length of line not changes during iterations for some fractals. Examples are w-curves or Krishna anklet. Other types of fractals are created using rotation of lines in space. For example Koch snowflake or hexagram. Mentioned algorithm type used to generate fractal can be enhanced by adding more shapes on user request. Not only parameters of algorithm will apply there. Lot of parameters are possible there too. For example choosing radius of circles, or different length of given shapes, width of the line, omitting certain recursion calls or drawing unfilled lines as exchange for given line. With unfilled lines its possible to manage diameter between these lines. We applied given approach drawing w-curves and results shows interesting shapes apart from typical w-curve shape using high value for this diameter. Software product lines can help in such situations to generate all types easily and only evaluate given result remains when launching application is the only one remaining requirement.

\begin{figure}[H]  %vycentrovany obrazok grafu, vsadeny do odstavca
					\begin{center}
									\includegraphics[width=\linewidth]{fig/fractalsAnklet.png}
									\caption{Different anklet fractal shapes}
									\label{ankletFractalTypes}
					\end{center}
\end{figure}



\section{Resulting modularity and derived products} \label{resultingModularity}

Aspects helps to produce modular solutions and enhance functionality without modification of existing code. In case of separating concerns using them can prevent code scattering. Large parts of interacting code for logging, exception handling, third party functionality which is used because of code improvements can be moved to separated classes and let main logic for each concern remain in given place without such code to be directly included. Mentioned parts of such concerns are included during weaving. In case of product line approach we found that is possible to introduce mechanism to easy copy certain parts of given project and let project to be functional and possibly prepared for next development phase. 


\subsection{Modification of functionality and use of AspectJ language} \label{functionalityModiffication}

Developed game using AspectJ shows these mentioned benefits as crucial for purpose of this application. Other benefits using AspectJ enabling easier configuration provided by changing method calls with values provided by chosen approach. This approach can be changed only by adding or removing given aspects from execution. Developing such aspect requires only changing core of few methods of one type of given aspect copy to reach this goal. Aspects well suits for required features too. They well cover variable features. Adding such feature needs to prepare given aspects and join points for them. Application should be developed in respect to changing requirements. Provided code then should be parametrized to enable use of many features and possibility to configure application.

Using aspects not brings only benefits to development and refactoring of existing solution. AspectJ requires to include certain refactoring and code modifications to hang certain aspects on these modified parts. Aspects pointcuts are twice as long and lot of provided parameters are repeated many times. If these pointcuts are modified only in few places their copy is unreadable and is hard to distinguish amongst them. Other crucial problem is need to create empty methods called hooks to hang up certain aspect on them, because aspect oriented methods for changing behaviour of code inside method are missing. In many cases aspects are applied only on one method, not groups of methods. In larger applications it can happen that private variables are exposed to privileged aspects and all encapsulation benefits are lost. AspectJ is not only language witch supports aspect oriented programming, but in my opinion its most powerful way for software product line development including product derivation.


\subsection{Generating derivation according to feature model} \label{gameDerivationBattleship}

During our work we created annotations which enable selection of given classes, interfaces and aspects in final derivation. We prepared and connected these classes with configuration file to make such selection to be based on actual configuration. Changing one variable and applying derivation results in creation of different result. We let to generate all possible derivations for all implemented variable features from feature model to prove its functionality. We need only three type of basic annotations to mark classes to separate them. We also developed algorithm to evaluate expression which enables copy given files to result project. Expression consists of variables which identifies features of given feature model which serves as basis for software product line application.    


\section{Recent work} \label{recentWork}

Kód kt


\section{Conclusions and next work} \label{conclusions}

Analyzo
 

\bibliographystyle{abbrv} % plain or alpha are fine, too
\bibliography{aspectj}


\end{document}

